package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/twitchtv/twirp/exp/gen"
	"github.com/twitchtv/twirp/exp/gen/stringutils"
	"github.com/twitchtv/twirp/exp/gen/typemap"
)

func main() {
	versionFlag := flag.Bool("version", false, "print version and exit")
	flag.Parse()
	if *versionFlag {
		fmt.Println(gen.Version)
		os.Exit(0)
	}

	g := newGenerator()
	gen.Main(g)
}

func newGenerator() *generator {
	return &generator{
		output:              new(bytes.Buffer),
		fileToGoPackageName: make(map[*descriptor.FileDescriptorProto]string),
	}
}

type generator struct {
	reg                 *typemap.Registry
	output              *bytes.Buffer
	genPkgName          string
	fileToGoPackageName map[*descriptor.FileDescriptorProto]string
}

func (g *generator) Generate(in *plugin.CodeGeneratorRequest) *plugin.CodeGeneratorResponse {
	genFiles := gen.FilesToGenerate(in)
	g.reg = typemap.New(in.ProtoFile)

	resp := new(plugin.CodeGeneratorResponse)
	for _, f := range genFiles {
		for _, service := range f.Service {
			for _, method := range service.Method {
				respFile := g.generateCommand(f, service, method)
				if respFile != nil {
					resp.File = append(resp.File, respFile)
				}
			}
		}
	}

	return resp
}

func (g *generator) generateCommand(file *descriptor.FileDescriptorProto, svc *descriptor.ServiceDescriptorProto, method *descriptor.MethodDescriptorProto) *plugin.CodeGeneratorResponse_File {
	g.P("-- Code generated by protoc-gen-twirp_eclier ", gen.Version, "DO NOT EDIT")
	g.P("-- source: ", file.GetName())
	g.P("")

	svcName := serviceName(svc)
	methName := methodName(method)
	inputName := methodInputName(method)
	fsn := fullServiceName(file, svc)

	inputName = strings.Replace(inputName, "ID", "Id", -1)

	g.P(`script.verb = "`, svcName, ":", methName, `"`)
	g.P(`script.help = "Executes method `, methName, " on service ", svcName, " for twirp package ", fsn, `"`)
	g.P(`script.author = "machine-generated"`)
	g.P(`script.version = "`, gen.Version, `"`)
	g.P(`script.usage = ""`)
	g.P("")
	g.P(`local flag = require "flag"`)
	g.P(`local svc = require "svc"`)
	g.P("")
	g.P(`local fs = flag.new()`)
	g.P("")

	msgDef := g.reg.MessageDefinition(method.GetInputType())
	retDef := g.reg.MessageDefinition(method.GetOutputType())

	flags := map[string]string{}

	g.P("-- flags for ", inputName)
	for _, val := range msgDef.Descriptor.GetField() {
		suffix := ""
		vLabel := val.GetLabel()

		if vLabel == descriptor.FieldDescriptorProto_LABEL_REPEATED {
			suffix = "s"
		}

		switch val.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_INT64, descriptor.FieldDescriptorProto_TYPE_DOUBLE, descriptor.FieldDescriptorProto_TYPE_FIXED32, descriptor.FieldDescriptorProto_TYPE_FIXED64, descriptor.FieldDescriptorProto_TYPE_FLOAT, descriptor.FieldDescriptorProto_TYPE_INT32:
			flags[val.GetName()] = "number" + suffix
		case descriptor.FieldDescriptorProto_TYPE_BOOL:
			flags[val.GetName()] = "bool" + suffix
		case descriptor.FieldDescriptorProto_TYPE_STRING:
			flags[val.GetName()] = "string" + suffix
		}
	}

	for name, ty := range flags {
		g.P(`fs:`, ty, `("`, name, `", "", "value for message arg `, name, `")`)
	}

	g.P("")
	g.P(`script.usage = fs:usage()`)
	g.P("")
	g.P(`function run(arg)`)
	g.P(`  if arg[1] == "-help" or arg[1] == "--help" then`)
	g.P(`    print(fs:usage())`)
	g.P(`    return`)
	g.P(`  end`)
	g.P("")
	g.P(`  arg[0] = script.verb`)
	g.P(`  local flags = fs:parse(arg)`)
	g.P("")
	g.P(`  local resp = svc.`, svcName, `.`, methName, "(flags)")
	g.P("")

	for _, val := range retDef.Descriptor.GetField() {
		g.P(`  print("`, val.GetJsonName(), `:\t\t" .. tostring(resp.`, val.GetJsonName(), `))`)
	}

	g.P("end")

	resp := new(plugin.CodeGeneratorResponse_File)
	resp.Name = proto.String(eclierFileName(file, svcName, methName))
	resp.Content = proto.String(g.output.String())
	g.output.Reset()

	return resp
}

func (g *generator) P(args ...string) {
	for _, v := range args {
		g.output.WriteString(v)
	}
	g.output.WriteByte('\n')
}

func (g *generator) printComments(comments typemap.DefinitionComments, prefix string) {
	text := strings.TrimSuffix(comments.Leading, "\n")
	for _, line := range strings.Split(text, "\n") {
		g.P(prefix, strings.TrimPrefix(line, " "))
	}
}

func serviceName(service *descriptor.ServiceDescriptorProto) string {
	return stringutils.SnakeCase(service.GetName())
}

func clientName(service *descriptor.ServiceDescriptorProto) string {
	return serviceName(service) + "Client"
}

func fullServiceName(file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto) string {
	name := serviceName(service)
	if pkg := file.GetPackage(); pkg != "" {
		name = pkg + "." + name
	}
	return name
}

func methodName(method *descriptor.MethodDescriptorProto) string {
	return stringutils.SnakeCase(method.GetName())
}

// methodInputName returns the basename of the input type of a method in snake
// case.
func methodInputName(meth *descriptor.MethodDescriptorProto) string {
	fullName := meth.GetInputType()
	split := strings.Split(fullName, ".")
	return split[len(split)-1]
}

func eclierFileName(f *descriptor.FileDescriptorProto, svcName, methodName string) string {
	name := *f.Name
	if ext := path.Ext(name); ext == ".proto" || ext == ".protodevel" {
		name = name[:len(name)-len(ext)]
	}
	name += "_twirp_eclier_" + svcName + "_" + methodName + ".lua"
	return name
}

// Given a protobuf name for a Message, return the Go name we will use for that
// type, including its package prefix.
func (g *generator) goTypeName(protoName string) string {
	def := g.reg.MessageDefinition(protoName)
	if def == nil {
		gen.Fail("could not find message for", protoName)
	}

	var name string
	for _, parent := range def.Lineage() {
		name += parent.Descriptor.GetName() + "_"
	}
	name += def.Descriptor.GetName()
	return name
}

func (g *generator) goPackageName(file *descriptor.FileDescriptorProto) string {
	return g.fileToGoPackageName[file]
}

func fileDescSliceContains(slice []*descriptor.FileDescriptorProto, f *descriptor.FileDescriptorProto) bool {
	for _, sf := range slice {
		if f == sf {
			return true
		}
	}
	return false
}
